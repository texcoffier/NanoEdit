/*
 * tout pour creer une fractale :-)
 */
#include <math.h>		/* Pour sin et cos */
#include <GL/gl.h>		/* Pour OpenGL */
#include "o_objet.h"
#include "t_geometrie.h"	/* Pour Triplet */
#include "u_graphique.h"	/* Pour t_texte */
#include "u_etat.h"
#include "matrice.h"
#include "io.h"
#include "t_ifs.h"
#include "u_graphique.h"
#include "u_vue.h"
#include "u_etat_courant.h"
#include "pov.h"

/*
 * fractal ( rep rep rep ... ) avec taille
 * composition binaire ( + - / colorise ... )
 */

/*
 *****************************************************************************
 *****************************************************************************
 * OBJET FRACTAL : AFFICHAGES
 *****************************************************************************
 *****************************************************************************
 */

/*
 *****************************************************************************
 * Commun
 *****************************************************************************
 */

struct lrifs
{
  int	niveau;			/* Nombre de récursions */
  matrice *p[10] ;		/* Matrices à différentes puissances */
  int	taille ;		/* Largeur et Hauteur de la matrice */
  Triplet x, y ;		/* Pour éclatement affichage */
  Booleen seulement_les_actives ;
  Booleen affiche_transformations ;
  Booleen objet_parametre ;
  int couleur ;
  /*
   * Pour la composition fractal
   */
  matrice **m1;			/* La matrice de la premiere fractale */
  matrice **m2;			/* La matrice de la deuxieme fractale */
  Menu type;			/* type de composition */
} ;

static matrice* trouve_matrice_puissance(matrice *p[10], int n)
{
  if ( n < 1 )
    n = 1 ;
  if ( n > 9 )
    n = 9 ;
  if ( n==1 )
    return(p[1]) ;
  if ( !p[n] )
    p[n] = matrice_multiplie(trouve_matrice_puissance(p, n/2),
			     trouve_matrice_puissance(p, (n+1)/2)) ;
  return( p[n] ) ;
}

static matrice* trouve_matrice(matrice *p[10],
			      int puissance,
			      const char *urgent)
{
  return( trouve_matrice_puissance(p, (atoi(urgent)-5) + puissance) ) ;
}

/*
 *****************************************************************************
 * crée l'affichage POV correspondant
 *****************************************************************************
 */
static void liste_cree_pov(liste_transfo *l, struct lrifs *o, FILE *f)
{
  Triplet pt ;

  for(;l;l=l->suc)
    {
      fprintf(f,"object { o%x\n", (int)o);
      transfo_affiche_pov(l->mat, f) ;
      if ( o->couleur )
	{
	  (*transfo_origine)(l->mat, &pt, 1) ;
	  pigment(f, pt.x, pt.y, pt.z) ;
	}
      fprintf(f,"}\n");
    }
}

static void matrice_cree_pov(matrice *m
			     , FILE *f
			     , struct lrifs *o
			     )
{
  int i,j;

  if ( m == NULL )
    return ;
  for(i=0;i<m->dim;i++)
    for(j=0;j<m->dim;j++)
      {
	fprintf(f, "union {\n") ;
	liste_cree_pov(m->m[i][j], o, f);
	fprintf(f, "translate <%g, %g, %g>\n}\n"
		, i*o->x.x+j*o->y.x, i*o->x.y+j*o->y.y, i*o->x.z+j*o->y.z
		) ;
      }	
}

static void affiche_fractale_pov(struct lrifs *o, const Champ *c, const char *v)
{
  FILE *f ;

  if ( v[0]=='\0' ) return ;
  if ( OBJET(o)->fils == NULL )
    return ;

  f = (FILE*)atoi(v) ;

  fprintf(f, "#declare o%x = ", (int)o) ;
  c_sauve_type(FILS(o,0), &infos_L_affiche_pov, v) ;

  fprintf(f, "union {\n") ;
  matrice_cree_pov(trouve_matrice_puissance(o->p, o->niveau), f, o) ;
  fprintf(f, "}\n") ;
}


/*
 *****************************************************************************
 * Affichage GL
 *****************************************************************************
 */

static void liste_cree_gl(liste_transfo *l, GLuint list, struct lrifs *o)
{
  Transfo tm ;
  Triplet t ;
  GLfloat m[4] ;

  while(l!=NULL)
    {
      if ( o->couleur )
	{
	  /* Prend origine deuxième transformation */
	  if ( (*transfo_origine)(l->mat, &t, 1) )
	    {
	      m[0] = t.x ;
	      m[1] = t.y ;
	      m[2] = t.z ;
	      m[3] = 1 ;
	    }
	  else
	    {
	      m[0] = m[1] = m[2] = m[3] = 0.5 ;
	    }
	  glColor3fv(m) ;
	  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, m) ;
	}
      glPushMatrix();
      (*transfo_extrait)(l->mat, &tm, 0);
      u_change_repere(&tm) ;
      glCallList(list);
      glPopMatrix();	
      l=l->suc;
    }
}

static void matrice_cree_gl(matrice *m, GLuint list
			    , struct lrifs *o
			    )
{
  int i,j;

  if ( m == NULL )
    return ;
  for(i=0;i<m->dim;i++)
    for(j=0;j<m->dim;j++)
      {
	glPushMatrix() ;
	glTranslatef(i*o->x.x+j*o->y.x, i*o->x.y+j*o->y.y, i*o->x.z+j*o->y.z) ;
	liste_cree_gl(m->m[i][j], list, o);
	glPopMatrix() ;
      }

}

static void affiche_fractale_gl(struct lrifs *o,
				const Champ *c, const char*v)
{
  void *obj;
  GLuint list;

  if ( OBJET(o)->fils == NULL )
    return ;

  transfo_n_4x4_utilise() ;
  if (o->affiche_transformations)
    {
      POUR_LES_FILS(o, f,
                    if ( i_f )
                    u_affiche_objet(f, "") ;
                    ) ;
    }
  /* le premier fils est l'objet de base de la fractale */
  obj=OBJET(o)->fils->objet;
  /*
   * Premier affichage invisible pour cr\xe9er les Listes
   */
  glPushMatrix() ;
  glScalef(0,0,0) ;
  u_affiche_objet(obj, v) ;
  glPopMatrix() ;
  /*
   * Création de la liste
   */
  list=glGenLists(1);
  glNewList(list, GL_COMPILE);
  if (0 && ACTIF(o))
    t_repere() ;
  else
    u_affiche_objet(obj, v) ;
  glEndList();

  matrice_cree_gl(trouve_matrice(o->p, o->niveau, v), list, o);

  glDeleteLists(list, 1);
}

/*
 *****************************************************************************
 * affichage STL
 *****************************************************************************
 */

static void liste_cree_stl(liste_transfo *l, void *obj, const char*v)
{
  Transfo t, t2 ;
  
  t = globale_etat_courant.transfo ;
  while(l!=NULL)
    {
      (*transfo_extrait)(l->mat, &t2, 0);
      globale_etat_courant.transfo = u_produit_transfo(&t, &t2) ;
      c_sauve_type(obj, &infos_L_affiche_stl, v) ;
      l=l->suc;
    }
}

static void matrice_cree_stl(matrice *m, void *obj,
			     const Triplet *x, const Triplet *y, const char*v)
{
  int i,j;
  Transfo t ;

  if ( m == NULL )
    return ;
	
  t = globale_etat_courant.transfo ;
  for(i=0;i<m->dim;i++)
    for(j=0;j<m->dim;j++)
      {
	globale_etat_courant.transfo = t ;
	globale_etat_courant.transfo.origine.x = t.origine.x + i*x->x+j*y->x ;
	globale_etat_courant.transfo.origine.y = t.origine.y + i*x->y+j*y->y ;
	globale_etat_courant.transfo.origine.z = t.origine.z + i*x->z+j*y->z ;
	liste_cree_stl(m->m[i][j], obj, v);
      }
  globale_etat_courant.transfo = t ;
}


static void affiche_fractale_stl(struct lrifs *o,
				 const Champ *c, const char*v)
{
  /* le premier fils est l'objet de base de la fractale */
  if ( FILS(o,0) == NULL )
    return ;
  matrice_cree_stl(trouve_matrice(o->p, o->niveau, strchr(v,' ')+1)
		   , FILS(o,0), &o->x, &o->y, v);
}

/*
 *****************************************************************************
 *
 *****************************************************************************
 */

static void detruit_fractale(struct lrifs *o)
{
  int i ;

  for(i=1;i<TAILLE_TABLE(o->p);i++)
    {
      matrice_libere(o->p[i]);
      o->p[i] = NULL ;
    }
}

/*
 * Évalue la transformation
 */
static Transformation *fait_transfo(const void *tr)
{
  Transformation *trm, *a, *b ;
  const char *nom_fils;
  const Champ *c ;
	
  nom_fils=OBJET(tr)->classe->nom;

  if (strcmp(nom_fils,"applique")==0)
    {
      /*
       * On fait le produit des transformations sous le applique
       */
      trm = (*transfo_identite)() ;
      POUR_LES_FILS(tr, o,
		    {
		      a = trm ;
		      b = fait_transfo(o) ;
		      trm = (*transfo_multiplie)(a,b) ;
		      (*transfo_libere)(a) ;
		      (*transfo_libere)(b) ;
		    }
		    );
    }
  else
    {
      /*
       * Transformation de base
       */
      if ( !c_trouve_type(&tr, &c, &infos_L_transfo) )
	{
	  /*
	   * Transformation inconnue, on retourne l'identité
	   */
	  return( (*transfo_identite)() ) ;
	}
      /*
       * On retourne la transformation de base
       */
      trm = (*transfo_create)(&T(Transfo, tr, c)) ;
    }

  return trm;
}
/*
 * Rempli la matrice de transformation.
 * En créant les listes de transformations.
 */
static void rempli_matrice(struct lrifs *o)
{
  Liste *lobj, *lobj2;
  int ligne, col ;

  ligne = 0 ;
  col = 0 ;

  for( lobj=OBJET(o)->fils->suivant ; lobj ; lobj=lobj->suivant)
    {
      if ( ligne == o->taille )
	{
	  NOTE_CHAMP_INVALIDE(o, taille) ;
	  return ;
	}
      if ( lobj->objet==NULL )
	continue ;
      if ( o->seulement_les_actives && !ACTIF(lobj->objet) )
	continue ;

      if ( strcmp(OBJET(lobj->objet)->classe->nom, "lrifs") == 0 )
	{
	  for( lobj2=OBJET(lobj->objet)->fils->suivant ; lobj2 ;
	       lobj2=lobj2->suivant)
	    if ( lobj2->objet )
	      matrice_affecte(o->p[1],ligne,col,fait_transfo(lobj2->objet));
	  col++ ;
	  if ( col == o->taille )
	    {
	      ligne++ ;
	      col = 0 ;
	    }
	}
      else
	{
	  matrice_affecte(o->p[1],ligne,col,fait_transfo(lobj->objet));
	}
    }
  if ( o->taille != 1 && ligne != o->taille )
    NOTE_CHAMP_INVALIDE(o, taille) ;
}

static void changement_fractale(struct lrifs *o)
{
  transfo_n_4x4_utilise() ;
  detruit_fractale(o);
  o->p[1] = matrice_nouvelle(o->taille);	
  rempli_matrice(o);
  o->couleur = 0 ;
}


static char *info_fractale(struct lrifs *o)
{
  static char info[100];
	
  sprintf(info,"Mat. %dx%d Prof. = %i",o->taille, o->taille, o->niveau);
  return info;
}		
		
CLASSE(lrifs_commun, struct lrifs,

       BULLE_D_AIDE("Cet objet permet de créer un IFS ou LR-IFS\n")
       PAQUET(NB_ACTIFS)
       MENU("NON")
  
       CHAMP(niveau,
	     L_nombre_positif P_entier
	     Edite Sauve
	     LABEL("Niveau de details")
	     DEFAUT("1")
	     BULLE_D_AIDE("Nombre de recursions de la fractale")
	     )
       CHAMP(x, L_vecteur P_triplet DEFAUT("0 0 0") Init3d Edite Sauve)
       CHAMP(y, L_vecteur P_triplet DEFAUT("0 0 0") Init3d Edite Sauve)
       CHAMP(seulement_les_actives, L_booleen Edite Sauve DEFAUT("0")
	     BULLE_D_AIDE("Si vrai alors seulement les transformations\n"
			  "active au sens de NanoÉdit sont incluses\n"
			  "dans l'IFS\n")
	     )
       CHAMP(affiche_transformations, L_booleen Edite Sauve DEFAUT("0")
	     BULLE_D_AIDE("Si vrai alors seulement les transformations\n"
			  "utilisées sont affichées\n"
			  )
	     )
       CHAMP(objet_parametre, L_booleen Edite Sauve DEFAUT("0")
	     BULLE_D_AIDE("Si vrai alors la dernière transformation\n"
			  "donne un point utilisé pour paramétrer\n"
			  "la form de l'objet fils.\n"
			  )
	     )

       CHAMP(p[1], L_matrice_ifs) /* Pour pouvoir être extrait */

       CHAMP_VIRTUEL(L_affiche_gl(affiche_fractale_gl)
		     AFFICHAGE(Toujours_different))
       CHAMP_VIRTUEL(L_affiche_stl(affiche_fractale_stl))
       CHAMP_VIRTUEL(L_solide Obligatoire)
       CHAMP_VIRTUEL(L_affiche_pov(affiche_fractale_pov))


       DESTRUCTION(detruit_fractale)
       CHANGEMENT(changement_fractale)
       INFORMATIONS(info_fractale)
       )

CLASSE(lrifs, struct lrifs,
       SUR_CLASSE("lrifs_commun")
       EVENEMENT("LRIFS")	 /* Raccourci clavier */
       MENU("Figures/?d/LR-IFS")
       CHAMP(taille,
	     L_nombre_positif P_entier
	     Edite Sauve
	     LABEL("Taille de la matrice")
	     DEFAUT("1")
	     BULLE_D_AIDE("Nombre de colonne et lignes de la matrice NxN")
	     )
       )

/*
 *****************************************************************************
 * FRACTAL DEFINIE PAR DEUX FRACTALES
 *****************************************************************************
 */

static char *info_composition(struct lrifs *o)
{
  static char info[50];
  
  if ( o->p[1] == NULL )
    return("?") ;
  
  sprintf(info,"%s %d %dx%d",o->type.selection, o->niveau,
	  o->p[1]->dim, o->p[1]->dim);
  return info;
}	
	
static matrice* matrice_colorise(matrice *m1, matrice *m2)
{
  matrice *mat ;
  liste_transfo *l1, *l2 ;
  Transfo m ;
  int i, j, k ;

  if ( m1->dim != m2->dim )
    return(NULL) ;

  transfo_n_4x4_utilise() ;
  mat = matrice_duplique(m1) ;

  for(j=0; j<mat->dim; j++)
    for(i=0; i<mat->dim; i++)
      {
	l1 = mat->m[j][i] ;
	l2 = m2->m[j][i] ;
	while( l1 && l2 )
	  {
	    k = 0 ;
	    while( (*transfo_extrait)(l2->mat, &m, k++) )
	      (*transfo_ajoute)(l1->mat, &m) ;
	    l1 = l1->suc ;
	    l2 = l2->suc ;
	  }
      }
  return(mat) ;
}

static matrice* calcul_composition(int type, matrice *m1, matrice *m2)
{	
  if ( m1 == NULL || m2 == NULL )
    return(NULL) ;
  
  switch(type)
    {
    default: return(                        NULL) ;
    case 0 : return(        matrice_union(m1,m2)) ;
    case 1 : return(matrice_concatenation(m1,m2)) ;
    case 2 : return(      matrice_melange(m1,m2)) ;
    case 3 : return(   matrice_additionne(m1,m2)) ;
    case 4 : return(    matrice_multiplie(m1,m2)) ;
    case 5 : return(     matrice_colorise(m1,m2)) ;
    }
}
		
static void changement_composition(struct lrifs *o)
{	
  if ( TRACE(o) )
    eprintf("o->m1 = %d o->m2 = %d\n", *o->m1,*o->m2) ;

  if ( o->m1 == NULL || o->m2 == NULL || *o->m1 == NULL || *o->m2 == NULL )
    return ;

  if ( FILS_CHANGE(o) || CHAMP_CHANGE(o, type) )
    {
      o->couleur = ( o->type.index == 5 ) ;
      detruit_fractale(o) ;
      o->p[1] = calcul_composition(o->type.index, *o->m1,*o->m2) ;
    }
}


CLASSE(lrifs_compose, struct lrifs,
       SUR_CLASSE("lrifs_commun")
       MENU("Figures/?d/LR-IFS")
       EVENEMENT("LRIFS")	 /* Raccourci clavier */
       CHAMP(m1, L_pointeur_extrait TYPE_DANS_FILS(L_matrice_ifs) Extrait Obligatoire)
       CHAMP(m2, L_pointeur_extrait TYPE_DANS_FILS(L_matrice_ifs) Extrait Obligatoire)
       CHAMP(type,
	     LABEL("Type de composition")
	     P_option_menu E_option_menu
	     TE_TEXTE(
		      "Union\n"
		      "Concatenation\n"
		      "Melange\n"
		      "Addition\n"
		      "Multiplication\n"
		      "Colorié par le deuxième\n"
		      )
	     DEFAUT("Union")
	     Edite Sauve
	     )
       BULLE_D_AIDE("Cet objet permet de composer deux fractales\n")
       CHANGEMENT(changement_composition)
       INFORMATIONS(info_composition)
       )
