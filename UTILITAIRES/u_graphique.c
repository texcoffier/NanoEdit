/*
    NanoÉdit: Un modeleur algébrique interactif.
    Copyright (C) 1996-2004 Thierry EXCOFFIER, Université Claude Bernard, LIRIS

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Contact: Thierry.EXCOFFIER@liris.univ-lyon1.fr
*/
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "u_graphique.h"
#include "eprintf.h"

#include "u_base.h"
#include "u_etat_courant.h" /* Pour afficher les lignes de rappel */


void u_multiplie_epaisseur_ligne(float v)
{
  GLfloat w ;

  glGetFloatv(GL_LINE_WIDTH, &w) ;
  if ( w == 0 )
    w = 1 ;
  glLineWidth(v+w) ;
}

void u_multiplie_taille_point(float v)
{
  GLfloat w ;

  glGetFloatv(GL_POINT_SIZE, &w) ;
  if ( w == 0 )
    w = 1 ;
  glPointSize(v+w) ;
}

/*
 *
 */

void u_3d_2d(const Triplet *pt, Flottant *x, Flottant *y)
{
  GLdouble mv[16], pr[16] ;
  GLint vp[4] ;
  GLdouble xx, yy, zz ;
  
  glGetDoublev(GL_MODELVIEW_MATRIX,mv) ;
  glGetDoublev(GL_PROJECTION_MATRIX,pr) ;
  glGetIntegerv(GL_VIEWPORT,vp) ;

  if ( gluProject( pt->x, pt->y, pt->z, mv, pr, vp, &xx, &yy, &zz)
       != GL_TRUE )
    eprintf("gluProject error\n") ;
  
  *x = xx ;
  *y = yy ;
}

void u_2d_3d(Flottant x, Flottant y, Triplet *pt)
{
  GLdouble mv[16], pr[16] ;
  GLint vp[4] ;
  GLdouble xx, yy, zz ;

  glGetDoublev(GL_MODELVIEW_MATRIX,mv) ;
  glGetDoublev(GL_PROJECTION_MATRIX,pr) ;
  glGetIntegerv(GL_VIEWPORT,vp) ;

  if ( gluUnProject( x, y, 0.5,	mv, pr,	vp, &xx, &yy, &zz) != GL_TRUE )
       eprintf("gluUnProject error\n") ;
 
  pt->x = xx ;
  pt->y = yy ;
  pt->z = zz ;
}

#define POINT_GROSSISSANT 1
#define FACTEUR_GROSSISSEMENT 2

void t_tag_general(int numero, const Triplet *pt, const Triplet *couleur)
{
  glPushName(numero) ;
  glPushAttrib( GL_CURRENT_BIT | GL_POINT_BIT ) ;
  glColor3f(couleur->x, couleur->y, couleur->z) ;
#if POINT_GROSSISSANT
  u_multiplie_taille_point(FACTEUR_GROSSISSEMENT) ;
#else
  glPointSize(7) ;
#endif
  glDisable(GL_DEPTH_TEST) ;
  glBegin(GL_POINTS) ;
  t_triplet(pt) ;
  glEnd() ;
  glEnable(GL_DEPTH_TEST) ;
  glPopAttrib() ;
  glPopName() ;
}

void t_tag_decale(int numero, const Triplet *p
		  , const Triplet *couleur, int tx, int ty)
{
  Triplet pt ;
  Flottant x, y ;

  glPushName(numero) ;
  
  u_3d_2d(p, &x, &y) ;  
  u_2d_3d(x+tx, y+ty, &pt) ;
  glPushAttrib( GL_CURRENT_BIT | GL_POINT_BIT ) ;
  glColor3f(couleur->x, couleur->y, couleur->z) ;
#if POINT_GROSSISSANT
  u_multiplie_taille_point(FACTEUR_GROSSISSEMENT) ;
#else
  glPointSize(7) ;
#endif
  glDisable(GL_DEPTH_TEST) ;
  glBegin(GL_POINTS) ;
  t_triplet(&pt) ;
  glEnd() ;
  glEnable(GL_DEPTH_TEST) ;
  glPopAttrib() ;

  glPopName() ;
}


void t_tag(int numero, const Triplet *pt)
{
  const Triplet c = {1,0,1} ;
  t_tag_general(numero, pt, &c) ;
}

void t_tag_premier(int numero, const Triplet *pt)
{
  const Triplet c = {0,1,0} ;
  t_tag_general(numero, pt, &c) ;
}

void t_tag_dilatation(int numero, const Triplet *pt)
{
  const Triplet c = {1,1,0} ;
  t_tag_general(numero, pt, &c) ;
}

void t_tag_rotation(int numero, const Triplet *pt)
{
  const Triplet c = {0,1,1} ;
  t_tag_general(numero, pt, &c) ;
}

void t_tag_rotation2(int numero, const Triplet *pt)
{
  const Triplet c = {0,1,1} ;
  t_tag_decale(numero, pt, &c, 0, 7) ;
}

void t_tag_destruction(int numero, const Triplet *p)
{
  const Triplet c = {1,0,0} ;
  t_tag_decale(numero, p, &c,  7, 7) ;
}

void t_tag_poids(int numero, const Triplet *p)
{
  const Triplet c = {0,0,1} ;
  t_tag_decale(numero, p, &c,  0, -7) ;
}

void t_ligne_rappel(const Triplet *o)
{
  glPushAttrib( GL_CURRENT_BIT ) ;
  glColor3f(.5,.5,.5) ;
  glEnable(GL_LINE_STIPPLE);
  glLineStipple(1,0xF0F) ;
  glBegin(GL_LINE_STRIP) ;	/* On relie les points par une ligne brisee */
  glVertex3f(o->x, o->y ,o->z) ;
  glVertex3f(o->x, o->y ,0.  ) ;
  glVertex3f(o->x, 0.   ,0.  ) ;
  glVertex3f(0.  , 0.   ,0.  ) ;
  glEnd();
  glDisable(GL_LINE_STIPPLE);
  glPopAttrib() ;
}

void t_tag_origine(int numero, const Triplet *o)
{
  if ( globale_etat_courant.affiche_ligne_de_rappel )
    t_ligne_rappel(o) ;
  t_tag(numero, o) ;
}

void t_tag_origine_premier(int numero, const Triplet *o)
{
  if ( globale_etat_courant.affiche_ligne_de_rappel )
    t_ligne_rappel(o) ;
  t_tag_premier(numero, o) ;
}



/*
 * NE marche pas en cas de picking
 */

void t_tag_destruction_ne_marchat_pas(int numero, const Triplet *p)
{
  GLint vp[4] ;
  Flottant x, y ;

  glPushName(numero) ;
  u_3d_2d(p, &x, &y) ;
  
  glPushMatrix() ;		/* Sauvegarde matrice de modélisation */
  glLoadIdentity() ;		/* L'initialise à l'identité */
  glMatrixMode(GL_PROJECTION) ;	/* Passe en modification matrice projection */
  glPushMatrix() ;		/* Sauvegarde matrice de projection */
  glLoadIdentity() ;		/* Initialise à l'identité */
  glTranslatef(-1,-1,0) ;
  glGetIntegerv(GL_VIEWPORT,vp) ;
  glScalef(2./vp[2],2./vp[3],1.) ;

  glPushAttrib( GL_CURRENT_BIT | GL_POINT_BIT ) ;
  glColor3f(1,0,0) ;
  u_multiplie_taille_point(4) ;
  glBegin(GL_POINTS) ;
  glVertex2i(x+7,y+7) ;
  glEnd() ;
  glPopAttrib() ;

  glPopMatrix() ;
  glMatrixMode(GL_MODELVIEW) ;
  glPopMatrix() ;
  glPopName() ;
}


/*
 * Trace une grille
 */

void t_sol(const Triplet *normale, float t)
{
  int i ;

  glColor3f(0.5,0.5,0.5) ;
  glBegin(GL_LINES) ;
  t = 2*(t+1.1) ;

  if ( normale->z != 0. )
    for(i = -t ; i<=t ; i++)
      {
	glVertex3f(  (float)i,  (float)t ,0.) ;
	glVertex3f(  (float)i, -(float)t ,0.) ;
	glVertex3f(  (float)t,  (float)i ,0.) ;
	glVertex3f( -(float)t,  (float)i ,0.) ;
      }
  else
  if ( normale->y != 0. )
    for(i = -t ; i<=t ; i++)
      {
	glVertex3f(  (float)i, 0.,  (float)t ) ;
	glVertex3f(  (float)i, 0., -(float)t ) ;
	glVertex3f(  (float)t, 0.,  (float)i ) ;
	glVertex3f( -(float)t, 0.,  (float)i ) ;
      }
  else
    for(i = -t ; i<=t ; i++)
      {
	glVertex3f( 0., (float)i,   (float)t ) ;
	glVertex3f( 0., (float)i,  -(float)t ) ;
	glVertex3f( 0., (float)t,   (float)i ) ;
	glVertex3f( 0.,-(float)t,   (float)i ) ;
      }

  glEnd();
}

/*
 * Change le repere courant
 */

void u_transfo_vers_gl(const Transfo *t, GLdouble m[16])
{
  *m++ = t->v1.x ;
  *m++ = t->v1.y ;
  *m++ = t->v1.z ;
  *m++ = 0 ;
  *m++ = t->v2.x ;
  *m++ = t->v2.y ;
  *m++ = t->v2.z ;
  *m++ = 0 ;
  *m++ = t->v3.x ;
  *m++ = t->v3.y ;
  *m++ = t->v3.z ;
  *m++ = 0 ;
  *m++ = t->origine.x ;
  *m++ = t->origine.y ;
  *m++ = t->origine.z ;
  *m++ = 1 ;
}

void u_change_repere(const Transfo *t)
{
  GLdouble m[16] ;

  u_transfo_vers_gl(t, m) ;
  glMultMatrixd(m);
}

Transfo u_matrice_gl(GLdouble m[16])
{
  Transfo t ;

  t.origine.x = m[12] ;
  t.origine.y = m[13] ;
  t.origine.z = m[14] ;
  t.v1.x = m[0] ;
  t.v1.y = m[1] ;
  t.v1.z = m[2] ;
  t.v2.x = m[4] ;
  t.v2.y = m[5] ;
  t.v2.z = m[6] ;
  t.v3.x = m[8] ;
  t.v3.y = m[9] ;
  t.v3.z = m[10] ;

  return(t) ;
}

void u_recupere_matrice_gl_dans_etat_courant()
{
  GLdouble m[16] ;

  glGetDoublev(GL_MODELVIEW_MATRIX,m) ;
  globale_etat_courant.transfo = u_matrice_gl(m) ;
}


/*
 * Trace le repere unitaire
 */

void t_repere()
{
  GLfloat w ;

  glPushAttrib( GL_CURRENT_BIT | GL_LINE_BIT ) ;
  glGetFloatv(GL_LINE_WIDTH, &w) ;
  glLineWidth(2*w) ;

  glBegin(GL_LINES) ;
  glColor3f(1.,0.,0.) ;
  glVertex3f(0.,0.,0.) ;
  glVertex3f(1.,0.,0.) ;
  glColor3f(0.,1.,0.) ;
  glVertex3f(0.,0.,0.) ;
  glVertex3f(0.,1.,0.) ;
  glColor3f(0.,0.,1.) ;
  glVertex3f(0.,0.,0.) ;
  glVertex3f(0.,0.,1.) ;
  glEnd();

  glPopAttrib() ;
}

void t_fleche(const Triplet *base, const Triplet *sommet, int plein)
{
  Transfo t ;

  t.origine = *base ;

  t.v3 = u_soustrait_triplet(sommet, base) ;
  u_repere_de_vecteur(&t.v3,&t.v1,&t.v2) ;
  glPushMatrix() ;
  u_change_repere(&t) ;

  if ( plein )
    {
      glBegin(GL_TRIANGLES) ;
      glVertex3f(0.,0.,1.) ; glVertex3f( 1.,0.,0.) ; glVertex3f(0., 1.,0.) ;
      glVertex3f(0.,0.,1.) ; glVertex3f( 1.,0.,0.) ; glVertex3f(0.,-1.,0.) ;
      glVertex3f(0.,0.,1.) ; glVertex3f(-1.,0.,0.) ; glVertex3f(0., 1.,0.) ;
      glVertex3f(0.,0.,1.) ; glVertex3f(-1.,0.,0.) ; glVertex3f(0.,-1.,0.) ;
      glEnd() ;
    }
  else
    {
      glBegin(GL_LINES) ;
      glVertex3f( 0., 0.,1.) ; glVertex3f( 1., 0.,0.) ;
      glVertex3f( 0., 0.,1.) ; glVertex3f(-1., 0.,0.) ;
      glVertex3f( 0., 0.,1.) ; glVertex3f( 0., 1.,0.) ;
      glVertex3f( 0., 0.,1.) ; glVertex3f( 0.,-1.,0.) ;
      glEnd();
    }

  glPopMatrix() ;
}

void t_fleche_proportionnelle(const Triplet *base, const Triplet *sommet, int plein,
			      float taille_relative)
{
  Triplet v ;

  v = u_soustrait_triplet(sommet, base) ;
  v = u_triplet_fois_flottant(&v, 1-taille_relative) ;
  v = u_ajoute_triplet(base, &v) ;

  t_fleche(&v, sommet, plein) ;
}

void t_triangle(const Triplet *a, const Triplet *b, const Triplet *c)
{
  Triplet n ;

  n = u_normale_triangle(a, b, c) ;
  glNormal3f(n.x,n.y,n.z) ;
  t_triplet(a) ;
  t_triplet(b) ;
  t_triplet(c) ;
}




/*
 * Affiche un simple cube unitaire (entre le point 0,0,0 et 1,1,1).
 *
 * Cette fonction est un EXERCICE DE STYLE, elle n'est pas compréhensible
 * immédiatement. L'algorithme utilisé permet de tracer des carrés, cubes, ...
 * dans des espaces de dimension quelconques (même >3)...
 * Cette fonction n'est pas optimale en temps de calcul et n'est pas lisible...
 *
 * SI CELA NE VOUS AMUSE PAS, N'ESSAYEZ PAS DE LA COMPRENDRE.
 */

static void affiche_point(int point)
{
  glVertex3f(point&1, (point/2)&1, (point/4)&1) ;
}

void t_cube()
{
  int point, point2, direction ;
  const int nb_points = 1<<3 ;		/* Nombre de points dans le cube */

  glBegin(GL_LINES) ;
  for( point=0 ; point < nb_points ; point++ )
    for( direction=1 ; direction < nb_points ; direction*=2 )
	{
	  point2 = point ^ direction ;
	  if ( point2 > point )	/* Pour ne pas tracer 2* la même chose */
	    {
	      affiche_point(point) ;
	      affiche_point(point2) ;
	    }
	}
  glEnd() ;
}

void t_cercle()
{
  float x, y ;
  const float pas = 10 ;

  x = 1 ;
  y = 0 ;
  glBegin(GL_LINE_LOOP) ;
  do { glVertex2f(x,y) ; y += x/pas ; x -= y/pas ; } while( y>0 ) ;
  do { glVertex2f(x,y) ; y += x/pas ; x -= y/pas ; } while( y<0 ) ;
  glEnd() ;
}

void t_disque()
{
  float x, y ;
  const float pas = 10 ;

  x = 1 ;
  y = 0 ;
  glBegin(GL_POLYGON) ;
  do { glVertex2f(x,y) ; y += x/pas ; x -= y/pas ; } while( y>0 ) ;
  do { glVertex2f(x,y) ; y += x/pas ; x -= y/pas ; } while( y<0 ) ;
  glEnd() ;
}

void t_cercle_centre_rayon(const Triplet *c, Flottant r)
{
  glPushMatrix() ;
  glTranslatef(c->x, c->y, c->z) ;
  glScalef(r, r, 1) ;
  t_cercle() ;
  glPopMatrix() ;
}

void t_disque_centre_rayon(const Triplet *c, Flottant r)
{
  glPushMatrix() ;
  glTranslatef(c->x, c->y, c->z) ;
  glScalef(r, r, 1) ;
  t_disque() ;
  glPopMatrix() ;
}

void t_cube_ponctuel()
{
  int point ;
  const int nb_points = 8 ;		/* Nombre de points dans le cube */

  glBegin(GL_POINTS) ;
  for( point=0 ; point < nb_points ; point++ )
    affiche_point(point) ;
  glEnd() ;
}

void t_cube_facette()
{
  int direction, position, vx, vy, parite ;

  const int nb_points = 8 ;		/* Nombre de points dans le cube */

  glEnable(GL_LIGHTING) ;
  glEnable(GL_CULL_FACE) ;
  /*  glCullFace(GL_BACK) ; */
  glBegin(GL_QUADS) ;
  parite = 0 ;
  for(direction=1; direction<nb_points ; direction *=2 )
    {
      vx = (direction!=1) ? 1 : 2 ;
      vy = (direction!=4) ? 4 : 2 ;
      
      for(position=0;position<2;position++)
	{
	  glNormal3f((2*position-1)*(direction&1),
		     (2*position-1)*((direction/2)&1),
		     (2*position-1)*((direction/4)&1)) ;
	  if ( (parite == 1) ^ (position == 0) )
	    {
	      affiche_point( direction*position ) ;
	      affiche_point( direction*position ^ vy ) ;
	      affiche_point( direction*position ^ vy ^ vx ) ;
	      affiche_point( direction*position ^ vx ) ;
	    }
	  else
	    {
	      affiche_point( direction*position ) ;
	      affiche_point( direction*position ^ vx ) ;
	      affiche_point( direction*position ^ vx ^ vy ) ;
	      affiche_point( direction*position ^ vy ) ;
	    }
	}
      parite = 1 - parite ;
    }

  glEnd() ;
  glDisable(GL_LIGHTING) ;
  glDisable(GL_CULL_FACE) ;
}




/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  font.c
 *
 *  Draws some text in a bitmapped font.  Uses glBitmap() 
 *  and other pixel routines.  Also demonstrates use of 
 *  display lists.
 */

static GLubyte rasters[][13] = {
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, 
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x36,0x36,0x36}, 
{0x00,0x00,0x00,0x66,0x66,0xff,0x66,0x66,0xff,0x66,0x66,0x00,0x00}, 
{0x00,0x00,0x18,0x7e,0xff,0x1b,0x1f,0x7e,0xf8,0xd8,0xff,0x7e,0x18}, 
{0x00,0x00,0x0e,0x1b,0xdb,0x6e,0x30,0x18,0x0c,0x76,0xdb,0xd8,0x70}, 
{0x00,0x00,0x7f,0xc6,0xcf,0xd8,0x70,0x70,0xd8,0xcc,0xcc,0x6c,0x38}, 
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x1c,0x0c,0x0e}, 
{0x00,0x00,0x0c,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0c}, 
{0x00,0x00,0x30,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x30}, 
{0x00,0x00,0x00,0x00,0x99,0x5a,0x3c,0xff,0x3c,0x5a,0x99,0x00,0x00}, 
{0x00,0x00,0x00,0x18,0x18,0x18,0xff,0xff,0x18,0x18,0x18,0x00,0x00}, 
{0x00,0x00,0x30,0x18,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, 
{0x00,0x60,0x60,0x30,0x30,0x18,0x18,0x0c,0x0c,0x06,0x06,0x03,0x03}, 
{0x00,0x00,0x3c,0x66,0xc3,0xe3,0xf3,0xdb,0xcf,0xc7,0xc3,0x66,0x3c}, 
{0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x78,0x38,0x18}, 
{0x00,0x00,0xff,0xc0,0xc0,0x60,0x30,0x18,0x0c,0x06,0x03,0xe7,0x7e}, 
{0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0x7e,0x07,0x03,0x03,0xe7,0x7e}, 
{0x00,0x00,0x0c,0x0c,0x0c,0x0c,0x0c,0xff,0xcc,0x6c,0x3c,0x1c,0x0c}, 
{0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0xfe,0xc0,0xc0,0xc0,0xc0,0xff}, 
{0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc7,0xfe,0xc0,0xc0,0xc0,0xe7,0x7e}, 
{0x00,0x00,0x30,0x30,0x30,0x30,0x18,0x0c,0x06,0x03,0x03,0x03,0xff}, 
{0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xe7,0x7e,0xe7,0xc3,0xc3,0xe7,0x7e}, 
{0x00,0x00,0x7e,0xe7,0x03,0x03,0x03,0x7f,0xe7,0xc3,0xc3,0xe7,0x7e}, 
{0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x38,0x38,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x30,0x18,0x1c,0x1c,0x00,0x00,0x1c,0x1c,0x00,0x00,0x00}, 
{0x00,0x00,0x06,0x0c,0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x0c,0x06}, 
{0x00,0x00,0x00,0x00,0xff,0xff,0x00,0xff,0xff,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x03,0x06,0x0c,0x18,0x30,0x60}, 
{0x00,0x00,0x18,0x00,0x00,0x18,0x18,0x0c,0x06,0x03,0xc3,0xc3,0x7e}, 
{0x00,0x00,0x3f,0x60,0xcf,0xdb,0xd3,0xdd,0xc3,0x7e,0x00,0x00,0x00}, 
{0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xff,0xc3,0xc3,0xc3,0x66,0x3c,0x18}, 
{0x00,0x00,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe}, 
{0x00,0x00,0x7e,0xe7,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xe7,0x7e}, 
{0x00,0x00,0xfc,0xce,0xc7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc7,0xce,0xfc}, 
{0x00,0x00,0xff,0xc0,0xc0,0xc0,0xc0,0xfc,0xc0,0xc0,0xc0,0xc0,0xff}, 
{0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xfc,0xc0,0xc0,0xc0,0xff}, 
{0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xcf,0xc0,0xc0,0xc0,0xc0,0xe7,0x7e}, 
{0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xff,0xc3,0xc3,0xc3,0xc3,0xc3}, 
{0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e}, 
{0x00,0x00,0x7c,0xee,0xc6,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06}, 
{0x00,0x00,0xc3,0xc6,0xcc,0xd8,0xf0,0xe0,0xf0,0xd8,0xcc,0xc6,0xc3}, 
{0x00,0x00,0xff,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0}, 
{0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xdb,0xff,0xff,0xe7,0xc3}, 
{0x00,0x00,0xc7,0xc7,0xcf,0xcf,0xdf,0xdb,0xfb,0xf3,0xf3,0xe3,0xe3}, 
{0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xe7,0x7e}, 
{0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe}, 
{0x00,0x00,0x3f,0x6e,0xdf,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3,0x66,0x3c}, 
{0x00,0x00,0xc3,0xc6,0xcc,0xd8,0xf0,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe}, 
{0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0x7e,0xe0,0xc0,0xc0,0xe7,0x7e}, 
{0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff}, 
{0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3}, 
{0x00,0x00,0x18,0x3c,0x3c,0x66,0x66,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3}, 
{0x00,0x00,0xc3,0xe7,0xff,0xff,0xdb,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3}, 
{0x00,0x00,0xc3,0x66,0x66,0x3c,0x3c,0x18,0x3c,0x3c,0x66,0x66,0xc3}, 
{0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x3c,0x66,0x66,0xc3}, 
{0x00,0x00,0xff,0xc0,0xc0,0x60,0x30,0x7e,0x0c,0x06,0x03,0x03,0xff}, 
{0x00,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c}, 
{0x00,0x03,0x03,0x06,0x06,0x0c,0x0c,0x18,0x18,0x30,0x30,0x60,0x60}, 
{0x00,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c}, 
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc3,0x66,0x3c,0x18}, 
{0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x38,0x30,0x70}, 
{0x00,0x00,0x7f,0xc3,0xc3,0x7f,0x03,0xc3,0x7e,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xfe,0xc3,0xc3,0xc3,0xc3,0xfe,0xc0,0xc0,0xc0,0xc0,0xc0}, 
{0x00,0x00,0x7e,0xc3,0xc0,0xc0,0xc0,0xc3,0x7e,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x7f,0xc3,0xc3,0xc3,0xc3,0x7f,0x03,0x03,0x03,0x03,0x03}, 
{0x00,0x00,0x7f,0xc0,0xc0,0xfe,0xc3,0xc3,0x7e,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x30,0x30,0x30,0x30,0x30,0xfc,0x30,0x30,0x30,0x33,0x1e}, 
{0x7e,0xc3,0x03,0x03,0x7f,0xc3,0xc3,0xc3,0x7e,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xfe,0xc0,0xc0,0xc0,0xc0}, 
{0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x18,0x00}, 
{0x38,0x6c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x00,0x00,0x0c,0x00}, 
{0x00,0x00,0xc6,0xcc,0xf8,0xf0,0xd8,0xcc,0xc6,0xc0,0xc0,0xc0,0xc0}, 
{0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x78}, 
{0x00,0x00,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xfe,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xfc,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00}, 
{0xc0,0xc0,0xc0,0xfe,0xc3,0xc3,0xc3,0xc3,0xfe,0x00,0x00,0x00,0x00}, 
{0x03,0x03,0x03,0x7f,0xc3,0xc3,0xc3,0xc3,0x7f,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xe0,0xfe,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xfe,0x03,0x03,0x7e,0xc0,0xc0,0x7f,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x1c,0x36,0x30,0x30,0x30,0x30,0xfc,0x30,0x30,0x30,0x00}, 
{0x00,0x00,0x7e,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x18,0x3c,0x3c,0x66,0x66,0xc3,0xc3,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xc3,0xe7,0xff,0xdb,0xc3,0xc3,0xc3,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xc3,0x66,0x3c,0x18,0x3c,0x66,0xc3,0x00,0x00,0x00,0x00}, 
{0xc0,0x60,0x60,0x30,0x18,0x3c,0x66,0x66,0xc3,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0xff,0x60,0x30,0x18,0x0c,0x06,0xff,0x00,0x00,0x00,0x00}, 
{0x00,0x00,0x0f,0x18,0x18,0x18,0x38,0xf0,0x38,0x18,0x18,0x18,0x0f}, 
{0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, 
{0x00,0x00,0xf0,0x18,0x18,0x18,0x1c,0x0f,0x1c,0x18,0x18,0x18,0xf0}, 
{0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x8f,0xf1,0x60,0x00,0x00,0x00} 
};

static void makeRasterFont(void)
{
    GLuint i;

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    for (i = 32; i < 127; i++) {
        glNewList((int)makeRasterFont+i, GL_COMPILE);
        glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, rasters[i-32]);
        glEndList();
    }
}

void t_chaine(const char *s)
{
  if ( ! glIsList((int)makeRasterFont+'a') )
      makeRasterFont();
      
  glPushAttrib (GL_LIST_BIT);
  glListBase((int)makeRasterFont);
  glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *) s);
  glPopAttrib ();
}

void t_caractere(char c)
{
  if ( ! glIsList((int)makeRasterFont+'a') )
      makeRasterFont();
      
  glCallList((int)makeRasterFont + c);
}
/* Comment multiplier à gauche ?
void t_chaine_centree(const char *s)
{
  GLdouble m[16] = { 0 } ;

  m[0 ] = 1 ;
  m[5 ] = 1 ;
  m[10] = 1 ;
  m[15] = 1 ;
  m[3] = -strlen(s)*4 ;
  m[8] = -7.5 ;
  glMultMatrixd(m) ;

  glPushMatrix() ;
}
*/
void t_chaine_centree(const char *s)
{
  GLubyte *b ;
  int i, j, n, i_last ;

  glNormal3f(0,0,1) ;
  glPushMatrix() ;
  glScalef(1/9., 1/9., 1) ;
  glTranslatef(-(strlen(s)*9.)/2., -7, 0) ;
  n = 0 ;

  glBegin(GL_QUADS) ;
  for( ; *s; s++)
    {
      if ( *s >=' ' )
	{
	  b = rasters[*s - ' '] ;
	  for(j=0; j<13; j++)
	    {
	      for(i=0;;)
		{
		  for(;  (b[j] & (128>>i))==0 && i<8 ; i++)
		    {
		    }
		  if ( i==8 )
		    break ;
		
		  for(i_last=i+1 ; (b[j]&(128>>i_last)) && i_last<8;i_last++ )
		    {
		    }
		  glVertex2i(n+i, j) ;
		  glVertex2i(n+i_last, j) ;
		  glVertex2i(n+i_last, j+1) ;
		  glVertex2i(n+i, j+1) ;
		  i = i_last ;
		}
	      }
	  n += 9 ;
	}
    }
  glEnd() ;
  glPopMatrix() ;
}
